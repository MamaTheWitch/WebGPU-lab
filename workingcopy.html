<!doctype html>

<html>

<head>
  <meta charset="utf-8">
  <title>WebGPU Life</title>
  <link rel="stylesheet" type="text/css" href="index.css" />
</head>

<body>
  <canvas width="512" height="512"></canvas>
  <script type="module">
    const canvas = document.querySelector("canvas");

    if (!navigator.gpu) {
      throw new Error("WebGPU not supported on this browser.");
    }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error("No appropriate GPUAdapter found.");
    }

    const device = await adapter.requestDevice();

    const GRID_SIZE = 4;

    const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
    const uniformBuffer = device.createBuffer({
      label: "Grid Uniforms",
      size: uniformArray.byteLength,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(uniformBuffer, 0, uniformArray);

    const context = canvas.getContext("webgpu");
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
    context.configure({ device: device, format: canvasFormat, });

    const vertices = new Float32Array([
      -0.8, -0.8,
      0.8, -0.8,
      0.8, 0.8,

      -0.8, -0.8,
      0.8, 0.8,
      -0.8, 0.8,
    ]);

    const vertexBuffer = device.createBuffer({
      label: "Cell vertices",
      size: vertices.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(vertexBuffer, 0, vertices);

    const vertexBufferLayout = {
      arrayStride: 8,
      attributes: [{
        format: "float32x2",
        offset: 0,
        shaderLocation: 0,
      }],
    };

    const cellShaderModule = device.createShaderModule({
      label: "Cell shader",
      code: `
        struct VertexInput {
          @location(0) pos: vec2f,
          @builtin(instance_index) instance: u32,
        };

        struct VertexOutput {
          @builtin(position) pos: vec4f,
          @location(0) cell: vec2f,
        };

        @group(0) @binding(0) var<uniform> grid: vec2f;
        @group(0) @binding(1) var sampler1: sampler;
        @group(0) @binding(2) var texture1: texture_2d<f32>;
        @group(0) @binding(3) var textureSampler: sampler;

        @vertex
        fn vertexMain(input: VertexInput) -> VertexOutput {
          let i = f32(input.instance);
          let cell = vec2f(i % grid.x, floor(i / grid.x));
          let cellOffset = cell / grid * 2;
          let gridPos = (input.pos + 1) / grid - 1 + cellOffset;

          var output: VertexOutput;
          output.pos = vec4f(gridPos, 0, 1);
          output.cell = cell;
          output.cell = input.pos.xy;
          return output;
        };

        @fragment
        fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
          var c = input.cell * 0.5 + 0.5;
          c.y = 1.0 - c.y;

          // Use a texture array or switch case to select different textures based on the cell coordinate.
          // For simplicity, I'm using a single texture here.
          let color = textureSample(texture1, sampler1, c);          return vec4f(color.rgb, 1.0);
        };
      `,
    });

    // Load different textures for each square
    const textureUrls = [
      'pose1.jpg', 'pose2.jpg', 'pose3.jpg', 'button.jpg',
      // Add more texture URLs as needed
    ];

    const textureViews = await Promise.all(textureUrls.map(async (url) => {
      const imgElement = document.createElement('img');
      imgElement.src = url;
      await new Promise(resolve => { imgElement.onload = resolve; });
      return webGPUTextureFromImageBitmapOrCanvas(device, imgElement).createView();
    }));

    const bindGroupLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: 'uniform' } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'filtering' } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
      ],
    });

    const textureSampler = device.createSampler({});

    const bindGroups = textureViews.map((textureView, index) => {
  return device.createBindGroup({
    layout: bindGroupLayout,
    entries: [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: textureSampler },
      { binding: 2, resource: textureView },
    ],
  });
});

    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout],
    });

    const cellPipeline = device.createRenderPipeline({
      label: "Cell pipeline",
      layout: pipelineLayout,
      vertex: {
        module: cellShaderModule,
        entryPoint: "vertexMain",
        buffers: [vertexBufferLayout],
      },
      fragment: {
        module: cellShaderModule,
        entryPoint: "fragmentMain",
        targets: [{
          format: canvasFormat,
        }],
      },
    });

    const encoder = device.createCommandEncoder();
    const pass = encoder.beginRenderPass({
      colorAttachments: [{
        view: context.getCurrentTexture().createView(),
        loadOp: "clear",
        clearValue: [1, 1, 1, 0],
        storeOp: "store",
      }],
    });

    pass.setPipeline(cellPipeline);
    pass.setVertexBuffer(0, vertexBuffer);

    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
      pass.setBindGroup(0, bindGroups[i]);
      pass.draw(vertices.length / 2, 1);
    }

    pass.end();

    device.queue.submit([encoder.finish()]);

    function webGPUTextureFromImageBitmapOrCanvas(device, source) {
      const textureDescriptor = {
        size: { width: source.width, height: source.height, depthOrArrayLayers: 1 },
        format: 'rgba8unorm',
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
      };

      const texture = device.createTexture(textureDescriptor);

      device.queue.copyExternalImageToTexture(
        { source: source },
        { texture: texture },
        [source.width, source.height, 1]
      );

      return texture;
    }
  </script>
</body>

</html>
